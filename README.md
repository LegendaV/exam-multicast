# Билет №3. Multicast

В этом билете необходимо будет использовать динамический
полиморфизм для организации широковещательных сообщений.

## Обзор проекта

В этом репозитории находится незавершенный исходный код
проекта Multicast*).
Этот проект предназначен для того, чтобы в интерактивном
режиме передавать сообщения на несколько адресов UDP
и несколько устройств с последовательным интерфейсом.

*) Строго говоря, multicast - это способ передачи информации,
в котором отправляется один экземпляр сообщения для
нескольких клиентов.
Проект же отправляет несколько unicast-сообщений
каждому клиенту.
В случае этого экзаменационного билета название выбрано
условно, потому что не нашлось ничего лучше.

### Конфигурационный файл

Программа `multicast` в качестве единственного аргумента
командной строки принимает путь до конфигурационного файла,
в котором описаны клиенты-приемники широковещательных
сообщений.

Пример конфигурационного файла:
```
udp 127.0.0.1 9000
udp 127.0.0.1 9001
udp 127.0.0.1 9002
serial /dev/pts/0
serial /dev/pts/2
```

В нем описано 3 UDP клиента и 2 клиента с последовательным
интерфейсом.

### Рабочий цикл программы

Программа после запуска:
1. Валидирует аргументы командной строки.
2. Читает и валидирует конфигурацию.
3. Входит в бесконечный цикл, в котором принимает строки
  из `stdin` и переслывает ее всем клиентам.

### Ограничения

- Проект не кроссплатформенный, соберется только под
  POSIX-совместимую операционную систему.

## Сборка

Для сборки проекта выполните:

```sh
cmake -B build/
cmake --build build/
```

## Тестирование

Вручную проект можно протестировать в терминале.
Потребуется утилиты `socat`, `nc` и `cat`.

### Настройка UDP клиента

Для каждого клиента из конфигурационного файла запустите утилиту
`nc` в режиме слушающего UDP сокета.
Например, для

```
udp 127.0.0.1 9000
```

клиент настраивается так:

```sh
nc -ul 127.0.0.1 9000
```

### Настройка клиентов с последовательным интерфейсом

Для каждого клиента потребуется создать петлю с использованием
двух `/dev/pts/*` устройств.
В одно из устройств будет писать программа `multicast`,
из другого устройства будет читать терминал при помощи `cat`.
Петля создает при помощи утилиты `socat`.

Для каждого клиента в конфигурации создайте петлю:

```sh
socat -d -d pty,raw,echo=0 pty,raw,echo=0
2026/01/19 18:17:37 socat[269419] N PTY is /dev/pts/0
2026/01/19 18:17:37 socat[269419] N PTY is /dev/pts/5
2026/01/19 18:17:37 socat[269419] N starting data transfer loop with FDs [6,6] and [8,8]
```

В выводе `socat` видно, что было создано два устройства,
`/dev/pts/0` и `/dev/pts/5`.
В конфигурационный файл записываем `/dev/pts/0`,
а читать будем `/dev/pts/5`.

Для чтения в новом окне терминала (программу `socat` нельзя прерывать)
выполните:

```sh
cat < /dev/pts/5
```

### Запуск приложения

После того, как все клиенты настроены, запустите приложение:

```sh
./build/multicast ./config.cfg
Enter message:
```

и начните вводить сообщения.
Вы должны увидеть их в каждом окне терминала, где
запущен `nc` или `cat`.

## Задание

Что уже реализовано:
- разбор аргументов командной строки;
- система сборки;
- чтение и валидация конфигурации;
- чтение ввода из `stdin`;
- функция отправки сообщения по UDP;
- функция отправки сообщений по последовательному интерфейсу.

Что нужно реализовать:
Используя динамеческий полиморфизм, придумайте как создать и единообразно
обслуживать клиентов с разным типом (UDP и последовательный интерфейс).

Места, где в коде нужно внести изменения, помечены комментариями `TODO`:

```c++
// TODO: отправьте всем клиентам
```

По желанию можно написать юнит-тесты.
